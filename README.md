# Snake Game

This is a classic Snake game implemented in Python using the Pygame library. The game allows the player to control a snake and navigate it around the screen to eat food and grow longer. The objective is to avoid colliding with walls or the snake's own body. The game ends when the snake collides with a wall or itself.

## Getting Started

To run the Snake game, you will need to have Python and Pygame installed on your machine. Follow the steps below to get started:

1. Clone this repository to your local machine.
2. Install Python from the official Python website: [Python.org](https://www.python.org/)
3. Install Pygame by running the following command in your terminal or command prompt:
   
```
pip install pygame
```
4. Navigate to the cloned repository and run the `snake.py` file using Python:
   
```
python snake.py
```

## Game Controls

- Use the arrow keys (Up, Down, Left, Right) to control the snake's movement.
- Press the Up arrow key to speed up the snake.
- Press the Down arrow key to slow down the snake.

## Features

- Grid-based game environment with checkered background.
- Randomly generated food for the snake to eat.
- Snake movement based on player input.
- Snake grows longer when it eats food.
- Collision detection with walls and snake's own body.
- Game over screen with "GAME OVER" message.
- Adjustable snake speed using arrow keys.

## Code Structure

The code is organized into several functions and classes to handle different aspects of the game:

- `Snake` class: Holds information about the snake's body segments, direction of movement, and current status (frozen or alive).
- `draw_background()` function: Draws the checkered background of the game.
- `draw_snake(snake)` function: Draws the snake's body segments on the screen.
- `draw_food(food_pos)` function: Draws the food on the screen.
- `move(snake, food_pos)` function: Moves the snake's body segments based on the current direction.
- `check_dead(snake)` function: Checks if the snake has collided with a wall or itself.
- `generate_food(snake)` function: Generates a new position for the food.
- `game_over_message()` function: Displays the "GAME OVER" message on the screen.
- `get_dir_dict(x, y, x_lim, y_lim)` function: Returns a dictionary of adjacent cells and their directions relative to a given cell.

The game also includes two additional functions, `prims_algorithm()` and `hamiltonian_cycle()`, which are used to create a Minimum Spanning Tree (MST) and a Hamiltonian Cycle.

### Prim's Algorithm

Prim's Algorithm is used to generate a Minimum Spanning Tree (MST) with randomized choice instead of edge weights. In the Snake Game, the MST is created as a guide to construct a Hamiltonian Cycle around the game grid.

The `prims_algorithm()` function initializes a dictionary `conn_dict` to store the connections of all nodes in the guide grid. It then selects a random node to start the MST and begins the process of expanding the MST by adding connections to neighboring nodes. The algorithm randomly chooses available nodes from the frontier and connects them to nodes in the MST. This process continues until all nodes have been visited.

### Hamiltonian Cycle

A Hamiltonian Cycle is a path in a graph that visits each vertex exactly once and returns to the starting vertex. In the Snake Game, the Hamiltonian Cycle is constructed around the game grid using the MST as a guide.

The `hamiltonian_cycle(snake)` function takes the current `snake` object as input and builds a Hamiltonian Cycle that begins and ends at the snake's head. It uses the MST generated by Prim's Algorithm as a guideline to construct the cycle. The function selects the current final tile in the cycle and checks adjacent tiles for possible connections based on the MST connections. It ensures that the snake's body segments are ordered within the cycle.

The `is_ordered(cycle, segments)` function is used to check if the snake's body segments are ordered within the Hamiltonian Cycle. It checks if the head has overtaken the tail in the cycle or if the tail has overtaken the head. If the snake's body segments are not ordered, it means that the snake will collide with itself.

The `generate_move(snake, food_pos, cycle)` function determines the next optimal move for the snake based on the current `snake` object, the position of the food, and the Hamiltonian Cycle. It calculates the distance to the food for each possible move and selects the move with the shortest distance. If the snake has grown rapidly and the next position in the Hamiltonian Cycle will result in a collision with its own body, it selects the first available tile to move to.

## Contributing

Contributions to the Snake Game project are always welcome. Here are some ways you can contribute:

- Report any bugs or issues you encounter by opening a new issue on the project's GitHub repository.
- Suggest new features or improvements by opening a new issue or submitting a pull request.
- Spread the word about the Snake Game and help more people discover and enjoy it.

## License

This project is licensed under the [MIT License](LICENSE).

## Acknowledgements

- Thank you to the Pygame library for providing the tools necessary to create this Snake game.
- Inspiration for this project came from the classic Snake game found on old Nokia mobile phones.

## References

- [Pygame Documentation](https://www.pygame.org/docs/)
- [Python.org](https://www.python.org/)